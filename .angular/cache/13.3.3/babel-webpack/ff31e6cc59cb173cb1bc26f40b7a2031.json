{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Injector, NgModule } from '@angular/core';\nimport { getActionTypeFromInstance, Store, NGXS_PLUGINS } from '@ngxs/store';\nimport { tap, catchError } from 'rxjs/operators';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\n\nconst repeat =\n/**\r\n* @param {?} str\r\n* @param {?} times\r\n* @return {?}\r\n*/\n(str, times) => new Array(times + 1).join(str);\n/** @type {?} */\n\n\nconst pad =\n/**\r\n* @param {?} num\r\n* @param {?} maxLength\r\n* @return {?}\r\n*/\n(num, maxLength) => repeat('0', maxLength - num.toString().length) + num;\n/**\r\n * @param {?} time\r\n * @return {?}\r\n */\n\n\nfunction formatTime(time) {\n  return pad(time.getHours(), 2) + `:` + pad(time.getMinutes(), 2) + `:` + pad(time.getSeconds(), 2) + `.` + pad(time.getMilliseconds(), 3);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nclass ActionLogger {\n  /**\r\n   * @param {?} action\r\n   * @param {?} store\r\n   * @param {?} logWriter\r\n   */\n  constructor(action, store, logWriter) {\n    this.action = action;\n    this.store = store;\n    this.logWriter = logWriter;\n  }\n  /**\r\n   * @param {?} state\r\n   * @return {?}\r\n   */\n\n\n  dispatched(state) {\n    /** @type {?} */\n    const actionName = getActionTypeFromInstance(this.action);\n    /** @type {?} */\n\n    const formattedTime = formatTime(new Date());\n    /** @type {?} */\n\n    const message = `action ${actionName} @ ${formattedTime}`;\n    this.logWriter.startGroup(message); // print payload only if at least one property is supplied\n\n    if (this._hasPayload(this.action)) {\n      this.logWriter.logGrey('payload', Object.assign({}, this.action));\n    }\n\n    this.logWriter.logGrey('prev state', state);\n  }\n  /**\r\n   * @param {?} nextState\r\n   * @return {?}\r\n   */\n\n\n  completed(nextState) {\n    this.logWriter.logGreen('next state', nextState);\n    this.logWriter.endGroup();\n  }\n  /**\r\n   * @param {?} error\r\n   * @return {?}\r\n   */\n\n\n  errored(error) {\n    this.logWriter.logRedish('next state after error', this.store.snapshot());\n    this.logWriter.logRedish('error', error);\n    this.logWriter.endGroup();\n  }\n  /**\r\n   * @private\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n\n\n  _hasPayload(event) {\n    /** @type {?} */\n    const nonEmptyProperties = this._getNonEmptyProperties(event);\n\n    return nonEmptyProperties.length > 0;\n  }\n  /**\r\n   * @private\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n\n\n  _getNonEmptyProperties(event) {\n    /** @type {?} */\n    const keys = Object.keys(event);\n    /** @type {?} */\n\n    const values = keys.map(\n    /**\r\n    * @param {?} key\r\n    * @return {?}\r\n    */\n    key => event[key]);\n    return values.filter(\n    /**\r\n    * @param {?} value\r\n    * @return {?}\r\n    */\n    value => value !== undefined);\n  }\n\n}\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  ActionLogger.prototype.action;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  ActionLogger.prototype.store;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  ActionLogger.prototype.logWriter;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nclass LogWriter {\n  /**\r\n   * @param {?} options\r\n   */\n  constructor(options) {\n    this.options = options;\n    this.options = this.options ||\n    /** @type {?} */\n    {};\n    this.logger = options.logger || console;\n  }\n  /**\r\n   * @param {?} message\r\n   * @return {?}\r\n   */\n\n\n  startGroup(message) {\n    /** @type {?} */\n    const startGroupFn = this.options.collapsed ? this.logger.groupCollapsed : this.logger.group;\n\n    try {\n      startGroupFn.call(this.logger, message);\n    } catch (e) {\n      console.log(message);\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  endGroup() {\n    try {\n      this.logger.groupEnd();\n    } catch (e) {\n      this.logger.log('—— log end ——');\n    }\n  }\n  /**\r\n   * @param {?} title\r\n   * @param {?} payload\r\n   * @return {?}\r\n   */\n\n\n  logGrey(title, payload) {\n    /** @type {?} */\n    const greyStyle = 'color: #9E9E9E; font-weight: bold';\n    this.log(title, greyStyle, payload);\n  }\n  /**\r\n   * @param {?} title\r\n   * @param {?} payload\r\n   * @return {?}\r\n   */\n\n\n  logGreen(title, payload) {\n    /** @type {?} */\n    const greenStyle = 'color: #4CAF50; font-weight: bold';\n    this.log(title, greenStyle, payload);\n  }\n  /**\r\n   * @param {?} title\r\n   * @param {?} payload\r\n   * @return {?}\r\n   */\n\n\n  logRedish(title, payload) {\n    /** @type {?} */\n    const redishStyle = 'color: #FD8182; font-weight: bold';\n    this.log(title, redishStyle, payload);\n  }\n  /**\r\n   * @param {?} title\r\n   * @param {?} color\r\n   * @param {?} payload\r\n   * @return {?}\r\n   */\n\n\n  log(title, color, payload) {\n    if (this.isIE()) {\n      this.logger.log(title, payload);\n    } else {\n      this.logger.log('%c ' + title, color, payload);\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  isIE() {\n    /** @type {?} */\n    const ua = typeof window !== 'undefined' && window.navigator.userAgent ? window.navigator.userAgent : '';\n    /** @type {?} */\n\n    let msIE = false;\n    /** @type {?} */\n\n    const oldIE = ua.indexOf('MSIE ');\n    /** @type {?} */\n\n    const newIE = ua.indexOf('Trident/');\n\n    if (oldIE > -1 || newIE > -1) {\n      msIE = true;\n    }\n\n    return msIE;\n  }\n\n}\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  LogWriter.prototype.logger;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  LogWriter.prototype.options;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @record\r\n */\n\n\nfunction NgxsLoggerPluginOptions() {}\n\nif (false) {\n  /**\r\n   * Auto expand logged actions\r\n   * @type {?|undefined}\r\n   */\n  NgxsLoggerPluginOptions.prototype.collapsed;\n  /**\r\n   * Provide alternate console.log implementation\r\n   * @type {?|undefined}\r\n   */\n\n  NgxsLoggerPluginOptions.prototype.logger;\n  /**\r\n   * Disable the logger. Useful for prod mode.\r\n   * @type {?|undefined}\r\n   */\n\n  NgxsLoggerPluginOptions.prototype.disabled;\n  /**\r\n   * Predicate for actions to be the logged. Takes action and state snapshot as parameters\r\n   * @type {?|undefined}\r\n   */\n\n  NgxsLoggerPluginOptions.prototype.filter;\n}\n/** @type {?} */\n\n\nconst NGXS_LOGGER_PLUGIN_OPTIONS = new InjectionToken('NGXS_LOGGER_PLUGIN_OPTIONS');\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nlet NgxsLoggerPlugin = /*#__PURE__*/(() => {\n  class NgxsLoggerPlugin {\n    /**\r\n     * @param {?} _options\r\n     * @param {?} _injector\r\n     */\n    constructor(_options, _injector) {\n      this._options = _options;\n      this._injector = _injector;\n    }\n    /**\r\n     * @param {?} state\r\n     * @param {?} event\r\n     * @param {?} next\r\n     * @return {?}\r\n     */\n\n\n    handle(state, event, next) {\n      if (this._options.disabled || !\n      /** @type {?} */\n      this._options.filter(event, state)) {\n        return next(state, event);\n      }\n\n      this._logWriter = this._logWriter || new LogWriter(this._options); // Retrieve lazily to avoid cyclic dependency exception\n\n      this._store = this._store || this._injector.get(Store);\n      /** @type {?} */\n\n      const actionLogger = new ActionLogger(event, this._store, this._logWriter);\n      actionLogger.dispatched(state);\n      return next(state, event).pipe(tap(\n      /**\r\n      * @param {?} nextState\r\n      * @return {?}\r\n      */\n      nextState => {\n        actionLogger.completed(nextState);\n      }), catchError(\n      /**\r\n      * @param {?} error\r\n      * @return {?}\r\n      */\n      error => {\n        actionLogger.errored(error);\n        throw error;\n      }));\n    }\n\n  }\n\n  NgxsLoggerPlugin.ɵfac = function NgxsLoggerPlugin_Factory(t) {\n    return new (t || NgxsLoggerPlugin)(ɵngcc0.ɵɵinject(NGXS_LOGGER_PLUGIN_OPTIONS), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  NgxsLoggerPlugin.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgxsLoggerPlugin,\n    factory: NgxsLoggerPlugin.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgxsLoggerPlugin;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n  NgxsLoggerPlugin.prototype._store;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxsLoggerPlugin.prototype._logWriter;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxsLoggerPlugin.prototype._options;\n  /**\r\n   * @type {?}\r\n   * @private\r\n   */\n\n  NgxsLoggerPlugin.prototype._injector;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nconst USER_OPTIONS = new InjectionToken('LOGGER_USER_OPTIONS');\n/**\r\n * @param {?} options\r\n * @return {?}\r\n */\n\nfunction loggerOptionsFactory(options) {\n  /** @type {?} */\n  const defaultLoggerOptions = {\n    logger: console,\n    collapsed: false,\n    disabled: false,\n    filter:\n    /**\r\n    * @return {?}\r\n    */\n    () => true\n  };\n  return Object.assign({}, defaultLoggerOptions, options);\n}\n\nlet NgxsLoggerPluginModule = /*#__PURE__*/(() => {\n  class NgxsLoggerPluginModule {\n    /**\r\n     * @param {?=} options\r\n     * @return {?}\r\n     */\n    static forRoot(options) {\n      return {\n        ngModule: NgxsLoggerPluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsLoggerPlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_LOGGER_PLUGIN_OPTIONS,\n          useFactory: loggerOptionsFactory,\n          deps: [USER_OPTIONS]\n        }]\n      };\n    }\n\n  }\n\n  NgxsLoggerPluginModule.ɵfac = function NgxsLoggerPluginModule_Factory(t) {\n    return new (t || NgxsLoggerPluginModule)();\n  };\n\n  NgxsLoggerPluginModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxsLoggerPluginModule\n  });\n  NgxsLoggerPluginModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return NgxsLoggerPluginModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { NGXS_LOGGER_PLUGIN_OPTIONS, NgxsLoggerPlugin, NgxsLoggerPluginModule, USER_OPTIONS as ɵa, loggerOptionsFactory as ɵb }; //# sourceMappingURL=ngxs-logger-plugin.js.map","map":null,"metadata":{},"sourceType":"module"}