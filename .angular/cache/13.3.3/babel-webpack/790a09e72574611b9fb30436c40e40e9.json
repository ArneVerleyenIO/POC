{"ast":null,"code":"import _asyncToGenerator from \"/Users/arne.verleyen/Desktop/Projects/storyblokPOC/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * storyblok-js-client v0.0.0-development\n * Universal JavaScript SDK for Storyblok's API\n * (c) 2020-2022 Stobylok Team\n */\nimport t from \"axios\";\n\nfunction e(t) {\n  return \"number\" == typeof t && t == t && t !== 1 / 0 && t !== -1 / 0;\n}\n\nfunction r(t, r, s) {\n  if (!e(r)) throw new TypeError(\"Expected `limit` to be a finite number\");\n  if (!e(s)) throw new TypeError(\"Expected `interval` to be a finite number\");\n\n  var n = [],\n      i = [],\n      o = 0,\n      a = function () {\n    o++;\n    var e = setTimeout(function () {\n      o--, n.length > 0 && a(), i = i.filter(function (t) {\n        return t !== e;\n      });\n    }, s);\n    i.indexOf(e) < 0 && i.push(e);\n    var r = n.shift();\n    r.resolve(t.apply(r.self, r.args));\n  },\n      l = function () {\n    var t = arguments,\n        e = this;\n    return new Promise(function (s, i) {\n      n.push({\n        resolve: s,\n        reject: i,\n        args: t,\n        self: e\n      }), o < r && a();\n    });\n  };\n\n  return l.abort = function () {\n    i.forEach(clearTimeout), i = [], n.forEach(function (t) {\n      t.reject(new throttle.AbortError());\n    }), n.length = 0;\n  }, l;\n}\n\nr.AbortError = function () {\n  Error.call(this, \"Throttled function aborted\"), this.name = \"AbortError\";\n};\n\nconst s = function (t, e) {\n  if (!t) return null;\n  let r = {};\n\n  for (let s in t) {\n    let n = t[s];\n    e.indexOf(s) > -1 && null !== n && (r[s] = n);\n  }\n\n  return r;\n};\n\nvar n = {\n  nodes: {\n    horizontal_rule: t => ({\n      singleTag: \"hr\"\n    }),\n    blockquote: t => ({\n      tag: \"blockquote\"\n    }),\n    bullet_list: t => ({\n      tag: \"ul\"\n    }),\n    code_block: t => ({\n      tag: [\"pre\", {\n        tag: \"code\",\n        attrs: t.attrs\n      }]\n    }),\n    hard_break: t => ({\n      singleTag: \"br\"\n    }),\n    heading: t => ({\n      tag: `h${t.attrs.level}`\n    }),\n    image: t => ({\n      singleTag: [{\n        tag: \"img\",\n        attrs: s(t.attrs, [\"src\", \"alt\", \"title\"])\n      }]\n    }),\n    list_item: t => ({\n      tag: \"li\"\n    }),\n    ordered_list: t => ({\n      tag: \"ol\"\n    }),\n    paragraph: t => ({\n      tag: \"p\"\n    })\n  },\n  marks: {\n    bold: () => ({\n      tag: \"b\"\n    }),\n    strike: () => ({\n      tag: \"strike\"\n    }),\n    underline: () => ({\n      tag: \"u\"\n    }),\n    strong: () => ({\n      tag: \"strong\"\n    }),\n    code: () => ({\n      tag: \"code\"\n    }),\n    italic: () => ({\n      tag: \"i\"\n    }),\n\n    link(t) {\n      const e = { ...t.attrs\n      },\n            {\n        linktype: r = \"url\"\n      } = t.attrs;\n      return \"email\" === r && (e.href = `mailto:${e.href}`), e.anchor && (e.href = `${e.href}#${e.anchor}`, delete e.anchor), {\n        tag: [{\n          tag: \"a\",\n          attrs: e\n        }]\n      };\n    },\n\n    styled: t => ({\n      tag: [{\n        tag: \"span\",\n        attrs: t.attrs\n      }]\n    })\n  }\n};\n\nclass i {\n  constructor(t) {\n    t || (t = n), this.marks = t.marks || [], this.nodes = t.nodes || [];\n  }\n\n  addNode(t, e) {\n    this.nodes[t] = e;\n  }\n\n  addMark(t, e) {\n    this.marks[t] = e;\n  }\n\n  render(t = {}) {\n    if (t.content && Array.isArray(t.content)) {\n      let e = \"\";\n      return t.content.forEach(t => {\n        e += this.renderNode(t);\n      }), e;\n    }\n\n    return console.warn(\"The render method must receive an object with a content field, which is an array\"), \"\";\n  }\n\n  renderNode(t) {\n    let e = [];\n    t.marks && t.marks.forEach(t => {\n      const r = this.getMatchingMark(t);\n      r && e.push(this.renderOpeningTag(r.tag));\n    });\n    const r = this.getMatchingNode(t);\n    return r && r.tag && e.push(this.renderOpeningTag(r.tag)), t.content ? t.content.forEach(t => {\n      e.push(this.renderNode(t));\n    }) : t.text ? e.push(function (t) {\n      const e = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n      },\n            r = /[&<>\"']/g,\n            s = RegExp(r.source);\n      return t && s.test(t) ? t.replace(r, t => e[t]) : t;\n    }(t.text)) : r && r.singleTag ? e.push(this.renderTag(r.singleTag, \" /\")) : r && r.html && e.push(r.html), r && r.tag && e.push(this.renderClosingTag(r.tag)), t.marks && t.marks.slice(0).reverse().forEach(t => {\n      const r = this.getMatchingMark(t);\n      r && e.push(this.renderClosingTag(r.tag));\n    }), e.join(\"\");\n  }\n\n  renderTag(t, e) {\n    if (t.constructor === String) return `<${t}${e}>`;\n    return t.map(t => {\n      if (t.constructor === String) return `<${t}${e}>`;\n      {\n        let r = `<${t.tag}`;\n        if (t.attrs) for (let e in t.attrs) {\n          let s = t.attrs[e];\n          null !== s && (r += ` ${e}=\"${s}\"`);\n        }\n        return `${r}${e}>`;\n      }\n    }).join(\"\");\n  }\n\n  renderOpeningTag(t) {\n    return this.renderTag(t, \"\");\n  }\n\n  renderClosingTag(t) {\n    if (t.constructor === String) return `</${t}>`;\n    return t.slice(0).reverse().map(t => t.constructor === String ? `</${t}>` : `</${t.tag}>`).join(\"\");\n  }\n\n  getMatchingNode(t) {\n    if (\"function\" == typeof this.nodes[t.type]) return this.nodes[t.type](t);\n  }\n\n  getMatchingMark(t) {\n    if (\"function\" == typeof this.marks[t.type]) return this.marks[t.type](t);\n  }\n\n}\n\nconst o = (t = 0, e = t) => {\n  const r = Math.abs(e - t) || 0,\n        s = t < e ? 1 : -1;\n  return ((t = 0, e) => [...Array(t)].map(e))(r, (e, r) => r * s + t);\n},\n      a = (t, e, r) => {\n  const s = [];\n\n  for (const n in t) {\n    if (!Object.prototype.hasOwnProperty.call(t, n)) continue;\n    const i = t[n],\n          o = r ? \"\" : encodeURIComponent(n);\n    let l;\n    l = \"object\" == typeof i ? a(i, e ? e + encodeURIComponent(\"[\" + o + \"]\") : o, Array.isArray(i)) : (e ? e + encodeURIComponent(\"[\" + o + \"]\") : o) + \"=\" + encodeURIComponent(i), s.push(l);\n  }\n\n  return s.join(\"&\");\n};\n\nlet l = {},\n    c = {};\n\nclass h {\n  constructor(e, s) {\n    if (!s) {\n      let t = e.region ? `-${e.region}` : \"\",\n          r = !1 === e.https ? \"http\" : \"https\";\n      s = void 0 === e.oauthToken ? `${r}://api${t}.storyblok.com/v2` : `${r}://api${t}.storyblok.com/v1`;\n    }\n\n    let n = Object.assign({}, e.headers),\n        o = 5;\n    void 0 !== e.oauthToken && (n.Authorization = e.oauthToken, o = 3), void 0 !== e.rateLimit && (o = e.rateLimit), this.richTextResolver = new i(e.richTextSchema), \"function\" == typeof e.componentResolver && this.setComponentResolver(e.componentResolver), this.maxRetries = e.maxRetries || 5, this.throttle = r(this.throttledRequest, o, 1e3), this.accessToken = e.accessToken, this.relations = {}, this.links = {}, this.cache = e.cache || {\n      clear: \"manual\"\n    }, this.client = t.create({\n      baseURL: s,\n      timeout: e.timeout || 0,\n      headers: n,\n      proxy: e.proxy || !1\n    }), e.responseInterceptor && this.client.interceptors.response.use(t => e.responseInterceptor(t)), this.resolveNestedRelations = e.resolveNestedRelations || !0;\n  }\n\n  setComponentResolver(t) {\n    this.richTextResolver.addNode(\"blok\", e => {\n      let r = \"\";\n      return e.attrs.body.forEach(e => {\n        r += t(e.component, e);\n      }), {\n        html: r\n      };\n    });\n  }\n\n  parseParams(t = {}) {\n    return t.version || (t.version = \"published\"), t.token || (t.token = this.getToken()), t.cv || (t.cv = c[t.token]), Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(\",\")), t;\n  }\n\n  factoryParamOptions(t, e = {}) {\n    return ((t = \"\") => t.indexOf(\"/cdn/\") > -1)(t) ? this.parseParams(e) : e;\n  }\n\n  makeRequest(t, e, r, s) {\n    const n = this.factoryParamOptions(t, ((t = {}, e = 25, r = 1) => ({ ...t,\n      per_page: e,\n      page: r\n    }))(e, r, s));\n    return this.cacheResponse(t, n);\n  }\n\n  get(t, e) {\n    let r = `/${t}`;\n    const s = this.factoryParamOptions(r, e);\n    return this.cacheResponse(r, s);\n  }\n\n  getAll(t, e = {}, r) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const s = e.per_page || 25,\n            n = `/${t}`,\n            i = n.split(\"/\");\n      r = r || i[i.length - 1];\n      const a = yield _this.makeRequest(n, e, s, 1),\n            l = Math.ceil(a.total / s);\n      return ((t = [], e) => t.map(e).reduce((t, e) => [...t, ...e], []))([a, ...(yield _asyncToGenerator(function* (t = [], e) {\n        return Promise.all(t.map(e));\n      })(o(1, l), /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (t) {\n          return _this.makeRequest(n, e, s, t + 1);\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }()))], t => Object.values(t.data[r]));\n    })();\n  }\n\n  post(t, e) {\n    let r = `/${t}`;\n    return this.throttle(\"post\", r, e);\n  }\n\n  put(t, e) {\n    let r = `/${t}`;\n    return this.throttle(\"put\", r, e);\n  }\n\n  delete(t, e) {\n    let r = `/${t}`;\n    return this.throttle(\"delete\", r, e);\n  }\n\n  getStories(t) {\n    return this.get(\"cdn/stories\", t);\n  }\n\n  getStory(t, e) {\n    return this.get(`cdn/stories/${t}`, e);\n  }\n\n  setToken(t) {\n    this.accessToken = t;\n  }\n\n  getToken() {\n    return this.accessToken;\n  }\n\n  _cleanCopy(t) {\n    return JSON.parse(JSON.stringify(t));\n  }\n\n  _insertLinks(t, e) {\n    const r = t[e];\n    r && \"multilink\" == r.fieldtype && \"story\" == r.linktype && \"string\" == typeof r.id && this.links[r.id] ? r.story = this._cleanCopy(this.links[r.id]) : r && \"story\" === r.linktype && \"string\" == typeof r.uuid && this.links[r.uuid] && (r.story = this._cleanCopy(this.links[r.uuid]));\n  }\n\n  _insertRelations(t, e, r) {\n    if (r.indexOf(t.component + \".\" + e) > -1) if (\"string\" == typeof t[e]) this.relations[t[e]] && (t[e] = this._cleanCopy(this.relations[t[e]]));else if (t[e].constructor === Array) {\n      let r = [];\n      t[e].forEach(t => {\n        this.relations[t] && r.push(this._cleanCopy(this.relations[t]));\n      }), t[e] = r;\n    }\n  }\n\n  iterateTree(t, e) {\n    let r = t => {\n      if (null != t) if (t.constructor === Array) for (let e = 0; e < t.length; e++) r(t[e]);else if (t.constructor === Object) {\n        if (t._stopResolving) return;\n\n        for (let s in t) (t.component && t._uid || \"link\" === t.type) && (this._insertRelations(t, s, e), this._insertLinks(t, s)), r(t[s]);\n      }\n    };\n\n    r(t.content);\n  }\n\n  resolveLinks(t, e) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let r = [];\n\n      if (t.link_uuids) {\n        const s = t.link_uuids.length;\n        let n = [];\n        const i = 50;\n\n        for (let e = 0; e < s; e += i) {\n          const r = Math.min(s, e + i);\n          n.push(t.link_uuids.slice(e, r));\n        }\n\n        for (let t = 0; t < n.length; t++) {\n          (yield _this2.getStories({\n            per_page: i,\n            language: e.language,\n            version: e.version,\n            by_uuids: n[t].join(\",\")\n          })).data.stories.forEach(t => {\n            r.push(t);\n          });\n        }\n      } else r = t.links;\n\n      r.forEach(t => {\n        _this2.links[t.uuid] = { ...t,\n          _stopResolving: !0\n        };\n      });\n    })();\n  }\n\n  resolveRelations(t, e) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let r = [];\n\n      if (t.rel_uuids) {\n        const s = t.rel_uuids.length;\n        let n = [];\n        const i = 50;\n\n        for (let e = 0; e < s; e += i) {\n          const r = Math.min(s, e + i);\n          n.push(t.rel_uuids.slice(e, r));\n        }\n\n        for (let t = 0; t < n.length; t++) {\n          (yield _this3.getStories({\n            per_page: i,\n            language: e.language,\n            version: e.version,\n            by_uuids: n[t].join(\",\")\n          })).data.stories.forEach(t => {\n            r.push(t);\n          });\n        }\n      } else r = t.rels;\n\n      r.forEach(t => {\n        _this3.relations[t.uuid] = { ...t,\n          _stopResolving: !0\n        };\n      });\n    })();\n  }\n\n  resolveStories(t, e) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      let r = [];\n      if (void 0 !== e.resolve_relations && e.resolve_relations.length > 0 && (r = e.resolve_relations.split(\",\"), yield _this4.resolveRelations(t, e)), [\"1\", \"story\", \"url\"].indexOf(e.resolve_links) > -1 && (yield _this4.resolveLinks(t, e)), _this4.resolveNestedRelations) for (const t in _this4.relations) _this4.iterateTree(_this4.relations[t], r);\n      t.story ? _this4.iterateTree(t.story, r) : t.stories.forEach(t => {\n        _this4.iterateTree(t, r);\n      });\n    })();\n  }\n\n  cacheResponse(t, e, r) {\n    var _this5 = this;\n\n    return void 0 === r && (r = 0), new Promise( /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (s, n) {\n        let i = a({\n          url: t,\n          params: e\n        }),\n            o = _this5.cacheProvider();\n\n        if (\"auto\" === _this5.cache.clear && \"draft\" === e.version && (yield _this5.flushCache()), \"published\" === e.version && \"/cdn/spaces/me\" != t) {\n          const t = yield o.get(i);\n          if (t) return s(t);\n        }\n\n        try {\n          let r = yield _this5.throttle(\"get\", t, {\n            params: e,\n            paramsSerializer: t => a(t)\n          }),\n              l = {\n            data: r.data,\n            headers: r.headers\n          };\n          if (r.headers[\"per-page\"] && (l = Object.assign({}, l, {\n            perPage: parseInt(r.headers[\"per-page\"]),\n            total: parseInt(r.headers.total)\n          })), 200 != r.status) return n(r);\n          (l.data.story || l.data.stories) && (yield _this5.resolveStories(l.data, e)), \"published\" === e.version && \"/cdn/spaces/me\" != t && o.set(i, l), l.data.cv && (\"draft\" == e.version && c[e.token] != l.data.cv && _this5.flushCache(), c[e.token] = l.data.cv), s(l);\n        } catch (i) {\n          if (i.response && 429 === i.response.status && (r += 1) < _this5.maxRetries) return console.log(`Hit rate limit. Retrying in ${r} seconds.`), yield (l = 1e3 * r, new Promise(t => setTimeout(t, l))), _this5.cacheResponse(t, e, r).then(s).catch(n);\n          n(i);\n        }\n\n        var l;\n      });\n\n      return function (_x2, _x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n  }\n\n  throttledRequest(t, e, r) {\n    return this.client[t](e, r);\n  }\n\n  cacheVersions() {\n    return c;\n  }\n\n  cacheVersion() {\n    return c[this.accessToken];\n  }\n\n  setCacheVersion(t) {\n    this.accessToken && (c[this.accessToken] = t);\n  }\n\n  cacheProvider() {\n    return \"memory\" === this.cache.type ? {\n      get: t => l[t],\n      getAll: () => l,\n\n      set(t, e) {\n        l[t] = e;\n      },\n\n      flush() {\n        l = {};\n      }\n\n    } : {\n      get() {},\n\n      getAll() {},\n\n      set() {},\n\n      flush() {}\n\n    };\n  }\n\n  flushCache() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this6.cacheProvider().flush(), _this6;\n    })();\n  }\n\n}\n\nexport { h as default };","map":null,"metadata":{},"sourceType":"module"}