{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Host, NgModule, SimpleChange, ChangeDetectorRef, Injectable, Inject, Optional, Input, EventEmitter, Injector, Component, Output, ElementRef } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nfunction defaultEventArgumentFactory() {\n  return '$event';\n}\n\nconst EventArgumentToken = new InjectionToken('EventArgument', {\n  providedIn: 'root',\n  factory: defaultEventArgumentFactory\n});\nconst DynamicComponentInjectorToken = new InjectionToken('DynamicComponentInjector');\nlet ComponentOutletInjectorDirective = /*#__PURE__*/(() => {\n  class ComponentOutletInjectorDirective {\n    constructor(componentOutlet) {\n      this.componentOutlet = componentOutlet;\n    }\n\n    get componentRef() {\n      // NOTE: Accessing private APIs of Angular\n      return this.componentOutlet._componentRef;\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  ComponentOutletInjectorDirective.ɵfac = function ComponentOutletInjectorDirective_Factory(t) {\n    return new (t || ComponentOutletInjectorDirective)(i0.ɵɵdirectiveInject(i1.NgComponentOutlet, 1));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  ComponentOutletInjectorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ComponentOutletInjectorDirective,\n    selectors: [[\"\", \"ngComponentOutlet\", \"\"]],\n    exportAs: [\"ndcComponentOutletInjector\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DynamicComponentInjectorToken,\n      useExisting: ComponentOutletInjectorDirective\n    }])]\n  });\n  return ComponentOutletInjectorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ComponentOutletInjectorModule = /*#__PURE__*/(() => {\n  class ComponentOutletInjectorModule {}\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  ComponentOutletInjectorModule.ɵfac = function ComponentOutletInjectorModule_Factory(t) {\n    return new (t || ComponentOutletInjectorModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  ComponentOutletInjectorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ComponentOutletInjectorModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  ComponentOutletInjectorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return ComponentOutletInjectorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction createNewChange(val) {\n  return new SimpleChange(undefined, val, true);\n}\n\nfunction createChange(val, prevVal) {\n  return new SimpleChange(prevVal, val, false);\n}\n\nfunction noop() {}\n\nfunction getCtorParamTypes(ctor, reflect) {\n  return reflect.getMetadata('design:paramtypes', ctor);\n}\n/**\n * Extract type arguments from Angular Directive/Component\n */\n\n\nfunction extractNgParamTypes(type) {\n  var _a, _b; // NOTE: Accessing private APIs of Angular\n\n\n  return (_b = (_a = type === null || type === void 0 ? void 0 : type.ctorParameters) === null || _a === void 0 ? void 0 : _a.call(type)) === null || _b === void 0 ? void 0 : _b.map(param => param.type);\n}\n\nlet IoService = /*#__PURE__*/(() => {\n  class IoService {\n    constructor(differs, cfr, eventArgument, cdr) {\n      this.differs = differs;\n      this.cfr = cfr;\n      this.eventArgument = eventArgument;\n      this.cdr = cdr;\n      this.checkInit = this.failInit;\n      this.lastComponentInst = null;\n      this.inputsDiffer = this.differs.find({}).create();\n      this.compFactory = null;\n      this.outputsShouldDisconnect$ = new Subject();\n\n      this.outputsChanged = () => false;\n    }\n\n    get compRef() {\n      return this.compInjector.componentRef;\n    }\n\n    get componentInst() {\n      return this.compRef ? this.compRef.instance : null;\n    }\n\n    get componentInstChanged() {\n      if (this.lastComponentInst !== this.componentInst) {\n        this.lastComponentInst = this.componentInst;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    get compCdr() {\n      return this.compRef ? this.compRef.injector.get(ChangeDetectorRef) : null;\n    }\n\n    ngOnDestroy() {\n      this._disconnectOutputs();\n    }\n\n    init(componentInjector, options = {}) {\n      this.checkInit = componentInjector ? noop : this.failInit;\n      this.compInjector = componentInjector;\n\n      if (options.trackOutputChanges) {\n        const outputsDiffer = this.differs.find({}).create();\n\n        this.outputsChanged = outputs => !!outputsDiffer.diff(outputs);\n      }\n    }\n\n    update(inputs, outputs, inputsChanged, outputsChanged) {\n      this.checkInit();\n      this.updateIO(inputs, outputs);\n      const compChanged = this.componentInstChanged;\n\n      if (compChanged || inputsChanged) {\n        const inputsChanges = this._getInputsChanges();\n\n        if (inputsChanges) {\n          this._updateInputChanges(inputsChanges);\n        }\n\n        this.updateInputs(compChanged || !this.lastInputChanges);\n      }\n\n      if (compChanged || outputsChanged) {\n        this.bindOutputs();\n      }\n    }\n\n    maybeUpdate() {\n      this.checkInit();\n\n      if (this.componentInstChanged) {\n        this.updateInputs(true);\n        this.bindOutputs();\n        return;\n      }\n\n      if (this.outputsChanged(this.outputs)) {\n        this.bindOutputs();\n      }\n\n      if (!this.inputs) {\n        return;\n      }\n\n      const inputsChanges = this._getInputsChanges();\n\n      if (inputsChanges) {\n        const isNotFirstChange = !!this.lastInputChanges;\n\n        this._updateInputChanges(inputsChanges);\n\n        if (isNotFirstChange) {\n          this.updateInputs();\n        }\n      }\n    }\n\n    updateIO(inputs, outputs) {\n      this.inputs = inputs;\n      this.outputs = outputs;\n    }\n\n    updateInputs(isFirstChange = false) {\n      if (isFirstChange) {\n        this._updateCompFactory();\n      }\n\n      const compInst = this.componentInst;\n      let inputs = this.inputs;\n\n      if (!inputs || !compInst) {\n        return;\n      }\n\n      inputs = this._resolveInputs(inputs);\n      Object.keys(inputs).forEach(p => compInst[p] = inputs[p]); // Mark component for check to re-render with new inputs\n\n      if (this.compCdr) {\n        this.compCdr.markForCheck();\n      }\n\n      this.notifyOnInputChanges(this.lastInputChanges, isFirstChange);\n    }\n\n    bindOutputs() {\n      this._disconnectOutputs();\n\n      const compInst = this.componentInst;\n      let outputs = this.outputs;\n\n      if (!outputs || !compInst) {\n        return;\n      }\n\n      outputs = this._resolveOutputs(outputs);\n      Object.keys(outputs).filter(p => compInst[p]).forEach(p => compInst[p].pipe(takeUntil(this.outputsShouldDisconnect$)).subscribe(event => {\n        this.cdr.markForCheck();\n        return outputs[p](event);\n      }));\n    }\n\n    notifyOnInputChanges(changes = {}, forceFirstChanges) {\n      // Exit early if component not interested to receive changes\n      if (!this.componentInst.ngOnChanges) {\n        return;\n      }\n\n      if (forceFirstChanges) {\n        changes = this._collectFirstChanges();\n      }\n\n      this.componentInst.ngOnChanges(changes);\n    }\n\n    _disconnectOutputs() {\n      this.outputsShouldDisconnect$.next();\n    }\n\n    _getInputsChanges() {\n      return this.inputsDiffer.diff(this.inputs);\n    }\n\n    _updateInputChanges(differ) {\n      this.lastInputChanges = this._collectChangesFromDiffer(differ);\n    }\n\n    _collectFirstChanges() {\n      const changes = {};\n      const inputs = this.inputs;\n      Object.keys(inputs).forEach(prop => changes[prop] = createNewChange(inputs[prop]));\n      return this._resolveChanges(changes);\n    }\n\n    _collectChangesFromDiffer(differ) {\n      const changes = {};\n      differ.forEachAddedItem(record => changes[record.key] = createNewChange(record.currentValue));\n      differ.forEachChangedItem(record => changes[record.key] = createChange(record.currentValue, record.previousValue));\n      return this._resolveChanges(changes);\n    }\n\n    _resolveCompFactory() {\n      try {\n        try {\n          return this.cfr.resolveComponentFactory(this.compRef.componentType);\n        } catch (e) {\n          // Fallback if componentType does not exist (happens on NgComponentOutlet)\n          return this.cfr.resolveComponentFactory(this.compRef.instance.constructor);\n        }\n      } catch (e) {\n        // Factory not available - bailout\n        return null;\n      }\n    }\n\n    _updateCompFactory() {\n      this.compFactory = this._resolveCompFactory();\n    }\n\n    _resolveInputs(inputs) {\n      if (!this.compFactory) {\n        return inputs;\n      }\n\n      return this._remapIO(inputs, this.compFactory.inputs);\n    }\n\n    _resolveOutputs(outputs) {\n      outputs = this._processOutputs(outputs);\n\n      if (!this.compFactory) {\n        return outputs;\n      }\n\n      return this._remapIO(outputs, this.compFactory.outputs);\n    }\n\n    _processOutputs(outputs) {\n      const processedOutputs = {};\n      Object.keys(outputs).forEach(key => {\n        const outputExpr = outputs[key];\n\n        if (typeof outputExpr === 'function') {\n          processedOutputs[key] = outputExpr;\n        } else {\n          processedOutputs[key] = outputExpr && this._processOutputArgs(outputExpr);\n        }\n      });\n      return processedOutputs;\n    }\n\n    _processOutputArgs(output) {\n      const {\n        handler\n      } = output;\n      const args = 'args' in output ? output.args || [] : [this.eventArgument];\n      return event => handler(...args.map(arg => arg === this.eventArgument ? event : arg));\n    }\n\n    _resolveChanges(changes) {\n      if (!this.compFactory) {\n        return changes;\n      }\n\n      return this._remapIO(changes, this.compFactory.inputs);\n    }\n\n    _remapIO(io, mapping) {\n      const newIO = {};\n      Object.keys(io).forEach(key => {\n        const newKey = this._findPropByTplInMapping(key, mapping) || key;\n        newIO[newKey] = io[key];\n      });\n      return newIO;\n    }\n\n    _findPropByTplInMapping(tplName, mapping) {\n      for (const map of mapping) {\n        if (map.templateName === tplName) {\n          return map.propName;\n        }\n      }\n\n      return null;\n    }\n\n    failInit() {\n      throw Error('IoService: ComponentInjector was not set! Please call init() method!');\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  IoService.ɵfac = function IoService_Factory(t) {\n    return new (t || IoService)(i0.ɵɵinject(i0.KeyValueDiffers), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(EventArgumentToken), i0.ɵɵinject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  IoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IoService,\n    factory: IoService.ɵfac\n  });\n  return IoService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/* eslint-disable @angular-eslint/no-conflicting-lifecycle */\n\n\nlet DynamicIoDirective = /*#__PURE__*/(() => {\n  class DynamicIoDirective {\n    constructor(ioService, componentInjector) {\n      this.ioService = ioService;\n      this.componentInjector = componentInjector;\n      this.ioService.init(this.componentInjector);\n    }\n\n    get inputs() {\n      return this.ndcDynamicInputs || this.ngComponentOutletNdcDynamicInputs;\n    }\n\n    get outputs() {\n      return this.ndcDynamicOutputs || this.ngComponentOutletNdcDynamicOutputs;\n    }\n\n    ngOnChanges(changes) {\n      this.ioService.update(this.inputs, this.outputs, this.inputsChanged(changes), this.outputsChanged(changes));\n    }\n\n    ngDoCheck() {\n      this.ioService.maybeUpdate();\n    }\n\n    inputsChanged(changes) {\n      return 'ngComponentOutletNdcDynamicInputs' in changes || 'ndcDynamicInputs' in changes;\n    }\n\n    outputsChanged(changes) {\n      return 'ngComponentOutletNdcDynamicOutputs' in changes || 'ndcDynamicOutputs' in changes;\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicIoDirective.ɵfac = function DynamicIoDirective_Factory(t) {\n    return new (t || DynamicIoDirective)(i0.ɵɵdirectiveInject(IoService), i0.ɵɵdirectiveInject(DynamicComponentInjectorToken, 8));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicIoDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DynamicIoDirective,\n    selectors: [[\"\", \"ndcDynamicInputs\", \"\"], [\"\", \"ndcDynamicOutputs\", \"\"], [\"\", \"ngComponentOutletNdcDynamicInputs\", \"\"], [\"\", \"ngComponentOutletNdcDynamicOutputs\", \"\"]],\n    inputs: {\n      ndcDynamicInputs: \"ndcDynamicInputs\",\n      ngComponentOutletNdcDynamicInputs: \"ngComponentOutletNdcDynamicInputs\",\n      ndcDynamicOutputs: \"ndcDynamicOutputs\",\n      ngComponentOutletNdcDynamicOutputs: \"ngComponentOutletNdcDynamicOutputs\"\n    },\n    features: [i0.ɵɵProvidersFeature([IoService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return DynamicIoDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicIoModule = /*#__PURE__*/(() => {\n  class DynamicIoModule {}\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicIoModule.ɵfac = function DynamicIoModule_Factory(t) {\n    return new (t || DynamicIoModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicIoModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DynamicIoModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  DynamicIoModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], ComponentOutletInjectorModule]\n  });\n  return DynamicIoModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicComponent = /*#__PURE__*/(() => {\n  class DynamicComponent {\n    constructor(vcr) {\n      this.vcr = vcr;\n      this.ndcDynamicCreated = new EventEmitter();\n      this.componentRef = null;\n    }\n\n    ngOnChanges(changes) {\n      if (DynamicComponent.UpdateOnInputs.some(input => changes.hasOwnProperty(input))) {\n        this.createDynamicComponent();\n      }\n    }\n\n    createDynamicComponent() {\n      this.vcr.clear();\n      this.componentRef = null;\n\n      if (this.ndcDynamicComponent) {\n        this.componentRef = this.vcr.createComponent(this.ndcDynamicComponent, {\n          index: 0,\n          injector: this._resolveInjector(),\n          projectableNodes: this.ndcDynamicContent\n        });\n        this.ndcDynamicCreated.emit(this.componentRef);\n      }\n    }\n\n    _resolveInjector() {\n      let injector = this.ndcDynamicInjector || this.vcr.injector;\n\n      if (this.ndcDynamicProviders) {\n        injector = Injector.create({\n          providers: this.ndcDynamicProviders,\n          parent: injector\n        });\n      }\n\n      return injector;\n    }\n\n  }\n\n  DynamicComponent.UpdateOnInputs = ['ndcDynamicComponent', 'ndcDynamicInjector', 'ndcDynamicProviders', 'ndcDynamicContent'];\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  DynamicComponent.ɵfac = function DynamicComponent_Factory(t) {\n    return new (t || DynamicComponent)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DynamicComponent,\n    selectors: [[\"ndc-dynamic\"]],\n    inputs: {\n      ndcDynamicComponent: \"ndcDynamicComponent\",\n      ndcDynamicInjector: \"ndcDynamicInjector\",\n      ndcDynamicProviders: \"ndcDynamicProviders\",\n      ndcDynamicContent: \"ndcDynamicContent\"\n    },\n    outputs: {\n      ndcDynamicCreated: \"ndcDynamicCreated\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DynamicComponentInjectorToken,\n      useExisting: DynamicComponent\n    }]), i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function DynamicComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return DynamicComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicModule = /*#__PURE__*/(() => {\n  class DynamicModule {}\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicModule.ɵfac = function DynamicModule_Factory(t) {\n    return new (t || DynamicModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DynamicModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  DynamicModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, DynamicIoModule], DynamicIoModule]\n  });\n  return DynamicModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicAttributesDirective = /*#__PURE__*/(() => {\n  class DynamicAttributesDirective {\n    constructor(renderer, differs, injector, componentInjector) {\n      this.renderer = renderer;\n      this.differs = differs;\n      this.injector = injector;\n      this.componentInjector = componentInjector;\n      this.attrsDiffer = this.differs.find({}).create();\n    }\n\n    get _attributes() {\n      return this.ndcDynamicAttributes || this.ngComponentOutletNdcDynamicAttributes;\n    }\n\n    get _nativeElement() {\n      var _a;\n\n      return (_a = this.componentInjector.componentRef) === null || _a === void 0 ? void 0 : _a.location.nativeElement;\n    }\n\n    get _compType() {\n      var _a;\n\n      return (_a = this.componentInjector.componentRef) === null || _a === void 0 ? void 0 : _a.componentType;\n    }\n\n    get _isCompChanged() {\n      if (this.lastCompType !== this._compType) {\n        this.lastCompType = this._compType;\n        return true;\n      }\n\n      return false;\n    }\n\n    ngDoCheck() {\n      const isCompChanged = this._isCompChanged;\n      const changes = this.attrsDiffer.diff(this._attributes);\n\n      if (changes) {\n        this.lastAttrActions = this._changesToAttrActions(changes);\n      }\n\n      if (changes || isCompChanged && this.lastAttrActions) {\n        this._updateAttributes(this.lastAttrActions);\n      }\n    }\n\n    setAttribute(name, value, namespace) {\n      if (this._nativeElement) {\n        this.renderer.setAttribute(this._nativeElement, name, value, namespace);\n      }\n    }\n\n    removeAttribute(name, namespace) {\n      if (this._nativeElement) {\n        this.renderer.removeAttribute(this._nativeElement, name, namespace);\n      }\n    }\n\n    _updateAttributes(actions) {\n      // ? Early exit if no dynamic component\n      if (!this._compType) {\n        return;\n      }\n\n      Object.keys(actions.set).forEach(key => this.setAttribute(key, actions.set[key]));\n      actions.remove.forEach(key => this.removeAttribute(key));\n    }\n\n    _changesToAttrActions(changes) {\n      const attrActions = {\n        set: {},\n        remove: []\n      };\n      changes.forEachAddedItem(r => attrActions.set[r.key] = r.currentValue);\n      changes.forEachChangedItem(r => attrActions.set[r.key] = r.currentValue);\n      changes.forEachRemovedItem(r => attrActions.remove.push(r.key));\n      return attrActions;\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicAttributesDirective.ɵfac = function DynamicAttributesDirective_Factory(t) {\n    return new (t || DynamicAttributesDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(DynamicComponentInjectorToken, 8));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicAttributesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DynamicAttributesDirective,\n    selectors: [[\"\", \"ndcDynamicAttributes\", \"\"], [\"\", \"ngComponentOutletNdcDynamicAttributes\", \"\"]],\n    inputs: {\n      ndcDynamicAttributes: \"ndcDynamicAttributes\",\n      ngComponentOutletNdcDynamicAttributes: \"ngComponentOutletNdcDynamicAttributes\"\n    },\n    exportAs: [\"ndcDynamicAttributes\"]\n  });\n  return DynamicAttributesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicAttributesModule = /*#__PURE__*/(() => {\n  class DynamicAttributesModule {}\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicAttributesModule.ɵfac = function DynamicAttributesModule_Factory(t) {\n    return new (t || DynamicAttributesModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicAttributesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DynamicAttributesModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  DynamicAttributesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], ComponentOutletInjectorModule]\n  });\n  return DynamicAttributesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IoFactoryService = /*#__PURE__*/(() => {\n  class IoFactoryService {\n    constructor(differs, cfr, eventArgument, cdr) {\n      this.differs = differs;\n      this.cfr = cfr;\n      this.eventArgument = eventArgument;\n      this.cdr = cdr;\n    }\n\n    create() {\n      return new IoService(this.differs, this.cfr, this.eventArgument, this.cdr);\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  IoFactoryService.ɵfac = function IoFactoryService_Factory(t) {\n    return new (t || IoFactoryService)(i0.ɵɵinject(i0.KeyValueDiffers), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(EventArgumentToken), i0.ɵɵinject(i0.ChangeDetectorRef));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  IoFactoryService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: IoFactoryService,\n    factory: IoFactoryService.ɵfac\n  });\n  return IoFactoryService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction browserWindowFactory() {\n  return window;\n}\n\nconst WindowRefToken = new InjectionToken('WindowRef', {\n  providedIn: 'root',\n  factory: browserWindowFactory\n});\nlet WindowRefService = /*#__PURE__*/(() => {\n  class WindowRefService {\n    constructor(injector) {\n      this.injector = injector;\n      this.nativeWindow = this.injector.get(WindowRefToken, null);\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  WindowRefService.ɵfac = function WindowRefService_Factory(t) {\n    return new (t || WindowRefService)(i0.ɵɵinject(i0.Injector));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  WindowRefService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WindowRefService,\n    factory: WindowRefService.ɵfac,\n    providedIn: 'root'\n  });\n  return WindowRefService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction dynamicDirectiveDef(type, inputs, outputs) {\n  return {\n    type,\n    inputs,\n    outputs\n  };\n}\n\nlet DynamicDirectivesDirective = /*#__PURE__*/(() => {\n  class DynamicDirectivesDirective {\n    constructor(iterableDiffers, ioFactoryService, windowRef, componentInjector) {\n      this.iterableDiffers = iterableDiffers;\n      this.ioFactoryService = ioFactoryService;\n      this.windowRef = windowRef;\n      this.componentInjector = componentInjector;\n      this.ndcDynamicDirectivesCreated = new EventEmitter();\n      this.dirRef = new Map();\n      this.dirIo = new Map();\n      this.dirsDiffer = this.iterableDiffers.find([]).create((_, def) => def.type);\n    }\n\n    get directives() {\n      return this.ndcDynamicDirectives || this.ngComponentOutletNdcDynamicDirectives;\n    }\n\n    get componentRef() {\n      return this.componentInjector.componentRef;\n    }\n\n    get compInstance() {\n      return this.componentRef && this.componentRef.instance;\n    }\n\n    get isCompChanged() {\n      if (this.lastCompInstance !== this.compInstance) {\n        this.lastCompInstance = this.compInstance;\n        return true;\n      }\n\n      return false;\n    }\n\n    get hostInjector() {\n      return this.componentRef.injector;\n    }\n\n    get hostVcr() {\n      // NOTE: Accessing private APIs of Angular\n      // eslint-disable-next-line @typescript-eslint/dot-notation\n      return this.componentRef['_viewRef']['_viewContainerRef'];\n    }\n\n    get reflect() {\n      return this.windowRef.nativeWindow.Reflect;\n    }\n\n    ngDoCheck() {\n      if (this.maybeDestroyDirectives()) {\n        return;\n      }\n\n      const dirsChanges = this.dirsDiffer.diff(this.directives);\n\n      if (!dirsChanges) {\n        return this.updateDirectives();\n      }\n\n      this.processDirChanges(dirsChanges);\n    }\n\n    ngOnDestroy() {\n      this.destroyAllDirectives();\n    }\n\n    maybeDestroyDirectives() {\n      if (this.isCompChanged || !this.componentRef) {\n        this.dirsDiffer.diff([]);\n        this.destroyAllDirectives();\n      }\n\n      return !this.componentRef;\n    }\n\n    processDirChanges(changes) {\n      changes.forEachRemovedItem(({\n        item\n      }) => this.destroyDirective(item));\n      const createdDirs = [];\n      changes.forEachAddedItem(({\n        item\n      }) => createdDirs.push(this.initDirective(item)));\n\n      if (createdDirs.length) {\n        this.ndcDynamicDirectivesCreated.emit(createdDirs.filter(Boolean));\n      }\n    }\n\n    updateDirectives() {\n      this.directives.forEach(dir => this.updateDirective(dir));\n    }\n\n    updateDirective(dirDef) {\n      const io = this.dirIo.get(dirDef.type);\n      io.update(dirDef.inputs, dirDef.outputs, false, false);\n      io.maybeUpdate();\n    }\n\n    initDirective(dirDef) {\n      if (this.dirRef.has(dirDef.type)) {\n        return;\n      }\n\n      const instance = this.createDirective(dirDef.type);\n      const dir = {\n        instance,\n        type: dirDef.type,\n        injector: this.hostInjector,\n        hostComponent: this.componentRef.instance,\n        hostView: this.componentRef.hostView,\n        location: this.componentRef.location,\n        changeDetectorRef: this.componentRef.changeDetectorRef,\n        onDestroy: this.componentRef.onDestroy\n      };\n      this.initDirIO(dir, dirDef.inputs, dirDef.outputs);\n      this.callInitHooks(instance);\n      this.dirRef.set(dir.type, dir);\n      return dir;\n    }\n\n    destroyAllDirectives() {\n      this.dirRef.forEach(dir => this.destroyDirRef(dir));\n      this.dirRef.clear();\n      this.dirIo.clear();\n    }\n\n    destroyDirective(dirDef) {\n      this.destroyDirRef(this.dirRef.get(dirDef.type));\n      this.dirRef.delete(dirDef.type);\n      this.dirIo.delete(dirDef.type);\n    }\n\n    initDirIO(dir, inputs, outputs) {\n      const io = this.ioFactoryService.create();\n      io.init({\n        componentRef: this.dirToCompDef(dir)\n      }, {\n        trackOutputChanges: true\n      });\n      io.update(inputs, outputs, !!inputs, !!outputs);\n      this.dirIo.set(dir.type, io);\n    }\n\n    dirToCompDef(dir) {\n      return {\n        changeDetectorRef: this.componentRef.changeDetectorRef,\n        hostView: this.componentRef.hostView,\n        location: this.componentRef.location,\n        destroy: this.componentRef.destroy,\n        onDestroy: this.componentRef.onDestroy,\n        injector: this.componentRef.injector,\n        instance: dir.instance,\n        componentType: dir.type\n      };\n    }\n\n    destroyDirRef(dir) {\n      const io = this.dirIo.get(dir.type);\n      io.ngOnDestroy();\n\n      if ('ngOnDestroy' in dir.instance) {\n        dir.instance.ngOnDestroy();\n      }\n    }\n\n    createDirective(dirType) {\n      const directiveInjector = Injector.create({\n        providers: [{\n          provide: dirType,\n          useClass: dirType,\n          deps: this.resolveDirParamTypes(dirType)\n        }, {\n          provide: ElementRef,\n          useValue: this.componentRef.location\n        }],\n        parent: this.hostInjector,\n        name: `DynamicDirectiveInjector:${dirType.name}@${this.componentRef.componentType.name}`\n      });\n      return directiveInjector.get(dirType);\n    }\n\n    resolveDirParamTypes(dirType) {\n      var _a, _b;\n\n      return (// First try Angular Compiler's metadata\n        (_b = (_a = extractNgParamTypes(dirType)) !== null && _a !== void 0 ? _a : // Then fallback to Typescript Reflect API\n        getCtorParamTypes(dirType, this.reflect)) !== null && _b !== void 0 ? _b : // Bailout\n        []\n      );\n    }\n\n    callInitHooks(obj) {\n      this.callHook(obj, 'ngOnInit');\n      this.callHook(obj, 'ngDoCheck');\n      this.callHook(obj, 'ngAfterContentInit');\n      this.callHook(obj, 'ngAfterContentChecked');\n      this.callHook(obj, 'ngAfterViewInit');\n      this.callHook(obj, 'ngAfterViewChecked');\n    }\n\n    callHook(obj, hook, args = []) {\n      if (obj[hook]) {\n        obj[hook](...args);\n      }\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicDirectivesDirective.ɵfac = function DynamicDirectivesDirective_Factory(t) {\n    return new (t || DynamicDirectivesDirective)(i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(IoFactoryService), i0.ɵɵdirectiveInject(WindowRefService), i0.ɵɵdirectiveInject(DynamicComponentInjectorToken, 8));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicDirectivesDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DynamicDirectivesDirective,\n    selectors: [[\"\", \"ndcDynamicDirectives\", \"\"], [\"\", \"ngComponentOutletNdcDynamicDirectives\", \"\"]],\n    inputs: {\n      ndcDynamicDirectives: \"ndcDynamicDirectives\",\n      ngComponentOutletNdcDynamicDirectives: \"ngComponentOutletNdcDynamicDirectives\"\n    },\n    outputs: {\n      ndcDynamicDirectivesCreated: \"ndcDynamicDirectivesCreated\"\n    },\n    features: [i0.ɵɵProvidersFeature([IoFactoryService])]\n  });\n  return DynamicDirectivesDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicDirectivesModule = /*#__PURE__*/(() => {\n  class DynamicDirectivesModule {}\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  DynamicDirectivesModule.ɵfac = function DynamicDirectivesModule_Factory(t) {\n    return new (t || DynamicDirectivesModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  DynamicDirectivesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DynamicDirectivesModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  DynamicDirectivesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], ComponentOutletInjectorModule]\n  });\n  return DynamicDirectivesModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ng-dynamic-component\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ComponentOutletInjectorDirective, ComponentOutletInjectorModule, DynamicAttributesDirective, DynamicAttributesModule, DynamicComponent, DynamicComponentInjectorToken, DynamicDirectivesDirective, DynamicDirectivesModule, DynamicIoDirective, DynamicIoModule, DynamicModule, EventArgumentToken, defaultEventArgumentFactory, dynamicDirectiveDef }; //# sourceMappingURL=ng-dynamic-component.mjs.map","map":null,"metadata":{},"sourceType":"module"}